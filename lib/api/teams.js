// Generated by CoffeeScript 1.9.2
(function() {
  var Promise, _, conf, couchUtils, getActorNameFromDB, getWorker, prepDoc, processReq, t, teams, utils, validation;

  couchUtils = require('../couch_utils');

  utils = require('../utils');

  _ = require('underscore');

  Promise = require('pantheon-helpers').promise;

  validation = require('../validation');

  conf = require('../config');

  prepDoc = require('../shared').prepDoc;

  t = {};

  t.doAction = require('../doAction');

  getWorker = function(resource) {
    var api, worker, workers;
    api = require('./index');
    workers = {};
    utils.getPlugins().forEach(function(plugin) {
      return workers[plugin.name] = plugin.worker;
    });
    worker = typeof workers[resource] === "function" ? workers[resource](api, validation, couchUtils) : void 0;
    return worker || {};
  };

  getActorNameFromDB = function(db) {
    return db.config.url.split(':')[1].slice(2);
  };

  processReq = function(req) {
    var actorName, db, orgDbName, params, teamName;
    params = req.params;
    orgDbName = 'org_' + params.orgId;
    teamName = params.teamId;
    if (teamName && teamName.indexOf('team_') === 0) {
      teamName = teamName.slice(5);
    }
    db = req.couch.use(orgDbName);
    actorName = req.session.user;
    return [orgDbName, db, actorName, teamName, params];
  };

  teams = {};

  teams.createTeam = function(dbName, actorName, teamName) {
    return t.doAction(dbName, actorName, null, {
      a: 't+',
      name: teamName
    });
  };

  teams.handleCreateTeam = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.createTeam(orgDbName, actorName, teamName)["catch"](function(err) {
      if (err.statusCode === 409) {
        return teams.getTeam(db, teamName);
      } else {
        return Promise.reject(err);
      }
    });
    return Promise.sendHttp(promise, resp);
  };

  teams.getTeam = function(orgDb, teamName) {
    var actorName, actorPromise, teamId, teamPromise;
    teamId = utils.formatId(teamName, 'team');
    actorName = getActorNameFromDB(orgDb);
    actorPromise = utils.getActor(couchUtils, actorName);
    teamPromise = orgDb.get(teamId, 'promise');
    return Promise.all([teamPromise, actorPromise]).then(function(arg) {
      var actor, preppedDoc, team;
      team = arg[0], actor = arg[1];
      preppedDoc = prepDoc(team, actor);
      return Promise.resolve(preppedDoc);
    });
  };

  teams.handleGetTeam = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.getTeam(db, teamName);
    return Promise.sendHttp(promise, resp);
  };

  teams.getTeams = function(orgDb) {
    var actorName, actorPromise, teamsPromise;
    actorName = getActorNameFromDB(orgDb);
    actorPromise = utils.getActor(couchUtils, actorName);
    teamsPromise = couchUtils.rewrite(orgDb, 'base', '/teams', 'promise');
    return Promise.all([teamsPromise, actorPromise]).then(function(arg) {
      var actor, preppedDocs, teams;
      teams = arg[0], actor = arg[1];
      preppedDocs = teams.map(function(team) {
        return prepDoc(team, actor);
      });
      return Promise.resolve(preppedDocs);
    });
  };

  teams.handleGetTeams = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.getTeams(db);
    return Promise.sendHttp(promise, resp);
  };

  teams.getAllTeams = function() {
    return utils.getOrgDbs().then(function(orgIds) {
      var allTeams;
      allTeams = orgIds.map(function(orgId) {
        var orgDb;
        orgDb = couchUtils.nano_system_user.use(orgId);
        return teams.getTeams(orgDb);
      });
      return Promise.all(allTeams);
    }).then(function(allTeams) {
      allTeams = _.flatten(allTeams, true);
      return Promise.resolve(allTeams);
    });
  };

  teams.getTeamRolesForUser = function(db, userName, callback) {

    /*
    return an array of team/role hashes to which the user belongs:
      [{team: <obj>, role: <str>}]
     */
    return db.viewWithList('base', 'by_role', 'get_team_roles', {
      include_docs: true,
      startkey: [userName],
      endkey: [userName, {}]
    }, callback);
  };

  teams.getAllTeamRolesForUser = function(userName) {
    return utils.getOrgDbs('promise').then(function(orgIds) {
      var teamRoles;
      teamRoles = orgIds.map(function(orgId) {
        var db;
        db = couchUtils.nano_system_user.use(orgId);
        return teams.getTeamRolesForUser(db, userName, 'promise');
      });
      return Promise.all(teamRoles);
    }).then(function(teamRoles) {
      teamRoles = _.flatten(teamRoles, true);
      return Promise.resolve(teamRoles);
    });
  };

  teams.addMember = function(dbName, actorName, teamName, role, userId) {
    var teamId;
    teamId = 'team_' + teamName;
    return t.doAction(dbName, actorName, teamId, {
      a: 'u+',
      role: role,
      user: userId
    });
  };

  teams.removeMember = function(dbName, actorName, teamName, role, userId) {
    var teamId;
    teamId = 'team_' + teamName;
    return t.doAction(dbName, actorName, teamId, {
      a: 'u-',
      role: role,
      user: userId
    });
  };

  teams.addAsset = function(dbName, actorName, teamName, resource, assetData) {
    var db;
    db = couchUtils.nano_user(actorName).use(dbName);
    return Promise.all([teams.getTeam(db, teamName, 'promise'), utils.getActor(couchUtils, actorName)]).then(function(arg) {
      var actor, handler, isAuthorized, team;
      team = arg[0], actor = arg[1];
      isAuthorized = validation.auth.add_team_asset(actor, team, resource);
      if (!isAuthorized) {
        return Promise.reject({
          statusCode: 401,
          error: 'unauthorized',
          msg: 'You are not authorized to add this asset'
        });
      }
      handler = getWorker(resource).getOrCreateAsset;
      if (!handler) {
        return Promise.reject({
          statusCode: 404,
          error: "not_found",
          msg: 'Resource, ' + resource + ', not found.'
        });
      }
      return handler(assetData, team, actor).then(function(newAsset) {
        if (newAsset == null) {
          return Promise.resolve(team);
        } else {
          return t.doAction(dbName, actorName, team._id, {
            a: 'a+',
            resource: resource,
            asset: newAsset
          });
        }
      });
    })["catch"](function(err) {
      console.error('add_asset_error', resource, assetData, err);
      return Promise.reject(err);
    });
  };

  teams.removeAsset = function(dbName, actorName, teamName, resource, assetId) {
    var teamId;
    teamId = 'team_' + teamName;
    return t.doAction(dbName, actorName, teamId, {
      a: 'a-',
      resource: resource,
      asset: {
        id: assetId
      }
    });
  };

  teams.handleAddMember = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.addMember(orgDbName, actorName, teamName, params.role, params.userId);
    return Promise.sendHttp(promise, resp);
  };

  teams.handleRemoveMember = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.removeMember(orgDbName, actorName, teamName, params.role, params.userId);
    return Promise.sendHttp(promise, resp);
  };

  teams.handleAddAsset = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.addAsset(orgDbName, actorName, teamName, params.resource, req.body);
    return Promise.sendHttp(promise, resp);
  };

  teams.handleRemoveAsset = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.removeAsset(orgDbName, actorName, teamName, params.resource, params.assetId);
    return Promise.sendHttp(promise, resp);
  };

  teams.getTeamDetails = function(db, teamName, actorName) {
    return Promise.all([teams.getTeam(db, teamName, 'promise'), utils.getActor(couchUtils, actorName)]).then(function(arg) {
      var actor, rsrcsPromises, team;
      team = arg[0], actor = arg[1];
      rsrcsPromises = {};
      _.forEach(team.rsrcs, function(resourceData, resourceName) {
        var assets, detailHandler;
        detailHandler = getWorker(resourceName).getTeamAssetDetails;
        if (detailHandler) {
          assets = resourceData.assets;
          return rsrcsPromises[resourceName] = detailHandler(assets, team, actor).then(function(assetDetails) {
            var zippedAssets;
            zippedAssets = _.zip(assets, assetDetails);
            _.each(zippedAssets, function(arg1) {
              var assetData, assetDetails;
              assetData = arg1[0], assetDetails = arg1[1];
              return assetData.details = assetDetails;
            });
            return Promise.resolve(assets);
          });
        } else {
          return rsrcsPromises[resourceName] = Promise.resolve([]);
        }
      });
      return Promise.hashAll(rsrcsPromises).then(function(rsrcs) {
        return Promise.resolve({
          rsrcs: rsrcs
        });
      });
    });
  };

  teams.handleGetTeamDetails = function(req, resp) {
    var actorName, db, orgDbName, params, promise, ref, teamName;
    ref = processReq(req), orgDbName = ref[0], db = ref[1], actorName = ref[2], teamName = ref[3], params = ref[4];
    promise = teams.getTeamDetails(db, teamName, req.session.user);
    return Promise.sendHttp(promise, resp);
  };

  teams.testing = t;

  module.exports = teams;

}).call(this);
