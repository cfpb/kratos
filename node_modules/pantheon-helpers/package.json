{
  "name": "pantheon-helpers",
  "version": "0.1.0",
  "description": "Couch Utils and Helpers for Microservices",
  "author": {
    "name": "David Greisen",
    "email": "david.greisen@cfpb.gov"
  },
  "scripts": {
    "test": "icake test"
  },
  "directories": {
    "lib": "lib"
  },
  "main": "lib/index",
  "dependencies": {
    "iced-runtime": "1.0.2",
    "basic-auth": "1.0.0",
    "nano-promise": "git+https://github.com/dgreisen-cfpb/nano-promise.git",
    "node-uuid": "1.4.2",
    "parse-links": "0.1.0",
    "promise": "^6.1.0",
    "request": "2.49.0",
    "underscore": "1.7.0",
    "underscore.string": "3.0.3",
    "follow": "0.11.4",
    "prompt": "0.2.14",
    "bunyan": "1.3.5",
    "coveralls": "~2.11.2"
  },
  "devDependencies": {
    "iced-coffee-script": "1.8.0-e",
    "jasmine-node": "1.14.5",
    "istanbul": "~0.3.15"
  },
  "engine": "node >= 0.4.1",
  "readme": "# Pantheon Helpers\n\n[![Build Status](https://travis-ci.org/cfpb/pantheon-helpers.svg?branch=master)](https://travis-ci.org/cfpb/pantheon-helpers)\n\n[![Coverage Status](https://coveralls.io/repos/cfpb/pantheon-helpers/badge.svg)](https://coveralls.io/r/cfpb/pantheon-helpers)\n\n## Description\nThe CFPB Pantheon of microservices help medium-sized development teams get their work done.\nPantheon Helpers is a small Node.js library to make it easier to build a microservice in Node.js with CouchDB.\n\n## Features\nThis library makes it easy to build an application with the following features:\n\n  * auditing\n  * validation\n  * rapid developement with a build script, and helpers for useful CouchDB and async promise patterns\n  * asyncronous server actions to provide snappy api response times even when the actions kicked off by the api take a long time\n\nPantheon helpers provide a framework for handling \"actions\".\nYou:\n  1. Define the actions your application will perform.\n  2. Write an action transform function for each action. \n     The transform function takes an action and a CouchDB document,\n     and idempotently transforms the document as required by the action.\n  3. Write a validation function for each action.\n     The validation function takes the action,\n     the user who performed the action (the actor),\n     and the old and new doc. It throws an error if\n     the action was invalid or unauthorized.\n  4. Write an asyncronous worker handler for any actions that result in side-effects. \n     The worker handler will be called _after_ the document has been written to the database,\n     and _after_ a response has been sent to the client performing the action.\n     The worker handler can run any slow, asyncronous code that the user shouldn't have to wait to complete before getting a response.\n       For instance, updating a remote server with data uploaded by the action.\n\nPantheon provides all the plumbing to ensure that these functions are run at the right time,\nin response to the right action,\nhave the expected result,\nand are logged.\n\n## Installation\n\nIn your microservice application's home directory, run:\n\n    npm install git+https://github.com/cfpb/pantheon-helpers.git\n\n    npm install -g coffee-script jasmine-node\n\n\n## Lifecycle of an action\n\n1) Perform an action:\n\n```coffeescript\ndoAction = require('pantheon-helpers/lib/doAction')\ndoAction(dbClient, 'designDocName', docId, {a: 'action name', ...}, callback)\n```\n\nThe dbClient must be bound to an authenticated user and a particular database.\nThe action hash must contain an `a` key with the action name,\nand it may contain any other keys/values needed to perform the action.\nIt may not contain the following reserved keys:\n`dt` (datetime stamp), `u` (user performing action),\nand `id` (uuid of the action).\n\nThe result of doAction will be\n(1) a stream, if no callback is specified,\n(2) a callback called with the resulting doc (or error),\n    if a callback function is specified, or\n(3) a promise, if callback is the string `\"promise\"`. \n\n2) The action is sent to CouchDB where the `do_action` [update handler](https://wiki.apache.org/couchdb/Document_Update_Handlers) takes over.\n\n3) The `do_action update handler` passes the event to its `action handler`.\nAction handlers must be defined in the design doc.\nActions are defined for each document type;\nyou can also define actions that can create new documents. \n\n4) The action handler receives the existing document\n(or a skeleton document if it needs to create a new doc),\nthe action hash passed into doAction,\nand the user who performed the action \n(based on the user bound to the dbClient passed to `doAction`.\nThe action handler DOES NOT RETURN ANYTHING.\nIt must modify the passed document (and action hash if desired) in place.\n\n5) If the action handler modified the document,\nthen the do_action update handler adds the action to the audit entry. \nIf the document was not modified,\nthen the unmodified document is return as the response for `doAction`.\n\n6) If the action modified the document,\nthen Couch next calls the validation function defined for the action.\nJust like action handlers, they are defined for each document type.\n\n7) The validation function is passed a the action hash,\nthe user that performed the action,\nthe document as it was before the action handler modified it,\nand the document as modified by the action handler.\nThe validation function can perform any validation logic it wants given these inputs.\nIf the action as performed by the user was not valid or was unauthorized,\nthe validation function should throw an error hash. \nFor an unauthorized action: \n`{state: 'unauthorized', err: 'descriptive error message'}`,\nfor an invalid action:\n`{state: 'invalid', err: 'descriptive error message'}`\n\n8a) If the validation function fails,\nthe document will not be modified,\nand `doAction` will return an unauthorized or invalid error.\n\n8b) If the validation function succeeds,\nthe modified document will be saved,\nand `doAction` will return the updated document.\n\n9) The worker process is constantly watching the database for changes.\nWhen the document is saved,\nthe worker process will wake up,\ndetermine which actions in the audit log have not been handled by the worker yet,\nand call the appropriate worker handler for each action.\nJust like action handlers and validation functions,\nworker handlers are defined for each document type.\n\n10) The worker handler is passed the action and the document.\nThe worker should do anything that has side effects/takes a long time,\nsuch as spinning up a service, calling another api endpoint, etc.\nWhatever is done MUST BE IDEMPOTENT. \nThere is no guarantee that the action will only be run through a worker once.\nThe worker must return a Promise.\nIf the worker fails,\nor partially fails,\nat whatever it is trying to do,\nit should return a rejected promise.\nIf it succeeds completely, it should return a resolved promise.\n\n11) If the worker handler failed,\nthen the returned error will be logged,\nand the action will me marked as failed so it can be retried at a later time.\nThe time to retry will be 1 minute for the first failure,\nthen 2, 4, 8, 16... for subsequent failures.\nIf the worker succeeded,\nthen the action will be marked as succeeding, so it is not tried again.\nRegardless of whether the worker handler succeeded or failed,\nif the value of the Promise returned by the worker handler is a hash that includes a `data` hash and a `path` array,\nthen the data hash will be merged with the hash in the document at path,\nand the resulting document will be saved to the database.\n\n\n## Usage\nFor the remainder of this guide,\nwe will be creating a microservice called \"Sisyphus\" in the directory `$SISYPHUS`.\nIf you would like to follow along,\ncreate a directory for the project and run:\n\n    export $SISYPHUS=/path/to/sisyphus/directory\n\nOur microservice will have endpoints to let us:\n\n  * create a boulder\n  * start rolling the boulder up the hill\n  * set the boulder rolling back down the hill\n  * get the current state of the boulder\n\nThe boulder will take 2 minutes to roll uphill,\nat which point it will escape Sisyphus \nand roll down the hill for 20 seconds.\nThen the whole process can start over again.\n\n### 1. Set up directory structure\nThere should already be a node_modules directory with pantheon-helpers within it.\nIf not, follow the installation instructions, above.\n\nExecute the pantheon-helpers bootstrap script:\n\n    $SISYPHUS/node_modules/pantheon-helpers/bootstrap\n\nYou should now have the following directory structure:\n\n    $SISYPHUS\n      |- Cakefile: build tool. Run `cake` within $SISYPHUS\n         to see available commands and arguments\n      |- spec: jasmine tests go here; recreate the src \n         directory structure to make it easy to find tests\n          |- apis: tests for api route handlers go here\n          |- design_docs: tests for design docs go here\n      |- src: coffeescript source files go here\n          |- config.coffee: configuration variables\n          |- config_secret.coffee: secret config variables;\n             ignored by git; imported by config.coffee\n          |- couch_utils.coffee: couch utilities, bound to your\n             couchdb instance defined in your config files\n          |- loggers.coffee: web and worker [bunyan](https://github.com/trentm/node-bunyan) loggers,\n             configurable via `config.LOGGERS.WEB` and `config.LOGGERS.WORKER`.\n             You will need to modify your config to send the logs to the appropriate location\n             (usually a file when in production).\n          |- app.coffee: executing this file starts the\n             web server\n          |- worker.coffee: executing this file starts\n             any/all backround workers\n          |- .gitignore: ignores config_secret\n          |- apis: api route handlers go here\n          |- design_docs: files to be imported by Kanso into CouchDB design docs go here\n\n      |- lib: javascript compiled from ./src by \n              `cake build` will go here\n          |- design_docs: some uncompiled javascript \n             generated by `cake start_design_doc` will\n             go here\n              |- pantheon: a symlink to a kanso design doc to support such things as\n                 retrying failed actions, and audit queries.\n\nTo complete the setup, \nYou will need to set your CouchDB config variables so Sisyphus can access CouchDB in either:\n\n * $SISYPHUS/src/config.coffee\n * $SISYPHUS/src/config_secret.coffee\n\nsystem username --\nthe username your application uses to log into CouchDB\n-- and the CouchDB password that user uses.\nHowever, you should not do this manually.\nInstead, you should use the cfpb/pantheon ansible scripts.\nSee that repo's README for more info.\n\n\n### 2. Getting ready to work\nRun `cake watch`. This will watch for changes to .coffee files and compile them to javascript.\n\n\n### 3. Set up your CouchDB database\n#### CouchDB credentials\nAdd your CouchDB credentials to $SISYPHUS/src/config.coffee and $SISYPHUS/src/config_secret.coffee. You will need to specify a username and password with which to access couchdb. Make sure the password is in config_secret.coffee.\n\nYou should see that the `cake watch` recompiles both config files as soon as you save them. \nIf you don't use `cake watch` you will need to run `cake build` every time you make a change.\n\nNow, we need to create the database in CouchDB.\nGo to `localhost:5984/_utils`, click \"Create Database\",\nand create a database called `boulders`.\nReplace `localhost:5984` with the host/port for your CouchDB instance.\nYou may need to have an admin create the database for you.\n\n\n#### Design documents\nWe use [Kanso](http://kan.so/) to load Design Docs into CouchDB. \nDesign Docs let us run custom code on CouchDB in a fashion similar to stored procedures in RDBMSs.\nYou should [familiarize yourself with CouchDB Design Docs](http://guide.couchdb.org/draft/design.html), if you are not already.\n\nA CouchDB instance can have many databases. Each database can have\nmany design docs. It can become difficult to ensure design docs remain\nup-to-date across all databases. Pantheon-helpers helps you manage your design docs.\n\nTo create a new design doc, run:\n\n    cake start_design_doc\n\nand enter `boulder` for name and `base boulder DB design doc` for description.\n\nNow we have a skeleton design doc in `$SISYPHUS/src/design_docs/boulder`. \nThe `./lib/app.coffee` is the primary entry point into your\ndesign doc.\nIf you take a look, it has placeholders for some of the more common design document features.\nOf particular note, are `audit.mixin` and `actions.mixin`. \nThese add the actions functionality (from `./lib/actions.coffee`)\nand audit functionality (from pantheon-helpers) to your design doc.\nWe will be modifying `./lib/actions.coffee` later to \ncreate the actions our app can perform.\n\nIf you look in `$SISYPHUS/lib/design_docs/boulder`,\nyou will see some files that are not in source.\nFirst, is the `kanso.json` file, \nthis is similar to node.js `package.json` or a bower `bower.json` file.\nIt tells kanso what to package up and send to couchdb.\n\nNext is the `_security` file.\nThis is a json file that couchdb uses to manage permissions.\nSee http://docs.couchdb.org/en/latest/intro/security.html and\nhttp://docs.couchdb.org/en/latest/api/database/security.html.\nYou should note that only the security document from the\nfirst design doc defined for each database will be loaded.\n\nFinally, in the `lib` subdirectory you will see a copy of underscore,\nand a symlink to the `pantheon-helpers/lib/design_docs` folder.\nAny files that you want to reference in your design doc must be in the `boulder` directory,\notherwise Kanso can't package them up.\nSo we add them here.\n\nNow that we have created our design document,\nwe have associate it with a type of database.\nTo do this, we create a new file at\n$SISYPHUS/src/design_docs/boulders.coffee with the following contents:\n\n    module.exports = ['boulder']\n\nThis tells Pantheon to add the `boulder` design doc to every\nsingle database that is (1) called `boulders` \nor (2) starts with `boulders_`.\nIf we wanted all those databases to also have another design doc installed, \nwe would add the name of the desired design doc to the exported array.\n\n### 3. Design the Sisyphus microservice\nRolling the boulder up the hill takes a long time (in web time): 2 minutes. \nWhen we make a request to roll the boulder up the hill,\nwe do not want to have to wait two minutes for a response.\nInstead, we would like to receive a response instantly that our request to roll the boulder up the hill has been accepted and is being processed.\nThen we want a background process to actually roll the boulder up the hill for two minutes.\n\nPantheon-helpers makes it easy to build this sort of decoupled application.\nFirst, let's figure out what our data is going to look like,\nthen let's figure out what actions we want to be able to perform on that data.\nFinally, we'll implement everything.\n\nOur boulder is going to be represented by a json document.\nWe want to know whether it's rolling up the hill,\nrolling down the hill, or at the bottom of the hill.\nWe're also curious about Zeus's reaction to events as they unfold.\nWe'll store Zeus's reaction to the most recent action right in the boulder document.\nThus, our json document will look like this:\n\n    { \"_id\": \"document ID\"\n    , \"type\": \"boulder\"\n    , \"status\": \"rolling up|rolling down|at bottom\"\n    , \"zeus\": \n      { \"is\": \"expectant|delighted|satisfied|mirthful|vengeful\"\n      }\n    }\n\nThat's pretty easy! \nWe don't even have to worry about the _id.\nCouchDB will create one for us if we don't set it explicitly.\n\nWe are going to need to transform our boulder document in four different ways:\n\n  1. create a new boulder (`b+`)\n  2. start rolling the boulder up the hill (`bu`)\n  3. make the boulder slip away and roll back down the hill (`bd`)\n  4. bring the boulder to rest at the bottom of the hill (`br`)\n\nObviously, we can never destroy a boulder since this is an eternal task.\nNote that not all of these actions are actually correspond to an endpoint. \nFor example, \na `br` will only ever be called by a worker handling a `bd` event.\n\nNow that we have created our design doc, we need to sync it with CouchDB. Just run\n\n    Cake sync_design_docs\n\nThis will update all the design documents in all your CouchDB databases.\n\n### 4. Testing\nTesting is easy because the system is loosely coupled,\nand each function you write \n(with the exception of worker handlers)\nshould have no side effects.\n\nBecause it is so easy, you should be writing a ton of tests.\n\nYou run your tests with `cake test`.\nYou will be writing your tests using jasmine-node,\nso you will need to write tests against the [v1.3 api](http://jasmine.github.io/1.3/introduction.html).\n\nYou should set up $SISYPHUS/spec to mirror your $SISYPHUS/src directory.\nTests for, e.g., $SISYPHUS/src/design_docs/boulder/lib/actions.coffee \nshould go in $SISYPHUS/src/design_docs/boulder/lib/actionsSpec.coffee.\nThe `Spec` postfix is needed so jasmine-node\n\nYou should make liberal use of jasmine spys to mock and spy on external dependencies.\n\nThere is already a .travis.yml file in your project skeleton.\nAll you need to do is turn your repo on in travis-ci.\n\n### 5. Implement CouchDB actions\nWe will define our actions in `src/design_docs/boulder/lib/actions.coffee`.\nWe need to define:\n  1. how to actually do the action, and\n  2. how to validate when an action is allowed\n\nSince most applications will have more than just one\ndocument type, we define functions in relation to the\ndocument type they can operate on.\nWe must also tell Pantheon-helpers how to tell the difference between document types.\n\nIn `src/design_docs/boulder/lib/actions.coffee`\n\n```coffeescript\n...\n\n# define our get_doc_type function.\n# will return boulder for boulder types\nget_doc_type = (doc) -> return doc.type\n\n# define our action handlers that will actually modify our doc\n# in response to actions.\na.do_actions = {\n  # we define all actions that can be performed on boulder docs\n  boulder: {\n    # an action is a function that receives the doc to be\n    # acted on, the action to be performed, and the\n    # user performing the action. It must update the\n    # doc in place. The do_action framework ensures that the\n    # document is saved only if the action handler actually\n    # changed the document.\n    'bu': (doc, action, actor) ->\n      doc.status = 'rolling up'\n    'bd': (doc, action, actor) ->\n      doc.status = 'rolling down'\n  }\n  # we define all actions that create new docs here (since we \n  # wouldn't know the type of a new doc until after it is created)\n  create: {\n    'b+': (doc, action, actor) ->\n      doc.type = 'boulder'\n      doc.status = 'at bottom'\n  }\n}\n\n# define our validation handlers that ensure that the action is valid.\na.validate_actions = {\n  # we define validation handlers for our boulder docs\n  boulder: {\n    # throw an error if the action is invalid;\n    bu: (event, actor, old_doc, new_doc) ->\n      if old_doc.status != 'at bottom'\n        throw {\n          state: 'invalid', \n          err: 'cannot start rolling boulder up until it reaches bottom'\n        }\n    bd: (event, actor, old_doc, new_doc) ->\n      if old_doc.status != 'rolling up'\n        throw {\n          state: 'invalid',\n          err: 'cannot roll down until boulder has started rolling up'\n        }\n\n    # You must define a validation function for all\n    # valid actions, even if there is no validation logic.\n    # Since b+ is always valid, we have an empty method.\n\n    # Validation for b+ is under the boulder doc_type, \n    # because the action handler defined above has already\n    # run and the boulder document has been created by this point.\n    b+: (event, actor, old_doc, new_doc) ->\n  }\n}\n\n# we want to show how far up the hill Sisyphus is. \n# but we don't want to store this - it will change \n# moment by moment - so we are going to create a doc_prep\n# function that takes a document and prepares it for\n# display. If you are offended by the horrible hackiness\n# of these calculations, you are encouraged to submit a \n# pull request.\n\n# Now, whenever you perform an action, you will receive back\n# a copy of the document with any modifications made by the\n# prep_boulder_for_display function.\n\nprep_boulder_for_display = (bouldDoc) ->\n  # get the most recent action for this boulder\n  last_action = bouldDoc.audit[bouldDoc.audit.length-1]\n\n  now = +new Date()\n  if not last_action or last_action.a = 'br'\n    bouldDoc.hillPosition = 0\n\n  else if last_action.a == 'bu'\n    bouldDoc.hillPosition = Math.floor((now - last_action.dt)*.9/120, .9)\n\n  else if last_action.a == 'bd'\n    bouldDoc.hillPosition = Math.ceiling((now - last_action.dt)*.9/20, 0)\n\na.do_action = do_action(\n                a.do_actions,\n                get_doc_type,\n                prep_boulder_for_display,\n              )\n...\n```\n\nWe have now defined how an action modifies a document, and we have defined when an action is valid.\n\nA couple of notes:\n  * Handler and validation functions cannot have any side effects.\n    You can't make http requests or grab other documents.\n  * Validation functions must throw either \n    {state: 'invalid', err: 'msg'} or {state: 'unauthorized', err: 'msg'}\n\nWe have now setup our design documents so CouchDB can handle our actions.\nHow do we actually perform an action from Node.js?\nPantheon-helpers provides a helper function, `doAction` to make this easy:\n\n```coffeescript  \n# get an authenticated couch client pointing to the boulders database\ndb = require('./couch_utils').nano_system_user.use('boulders')\n\n# import the do_action method\ndoAction = require('pantheon-helpers/lib/doAction')\n\n# do the action, passing in the database, the design document name where the action is defined, the document ID (or `null` if this action creates a new doc), and the action.\n\n# create a boulder\ndoAction(db, 'boulder', null, {a: 'b+'}, (err, boulder_doc) ->\n  # start rolling the boulder up the hill\n  doAction(db, 'boulder', boulder_doc._id, {a: 'bu'})\n)\n```\n\nAs you can see, an action is just a dictionary.\nThe action id is specified by the `a` key.\nYou can use any other keys you like, with the\nexception of the reserved system keys:\n`dt` (datetime stamp), `u` (user performing action),\nand `id` (uuid of the action)\nThe entire action dictionary is passed to your handler,\nvalidation, and worker functions, and is stored in the\naudit log.\n\n\n### 6. Create background worker\nOur actions now modify our document,\nbut they don't do anything in \"real life\".\nLet's change that.\n\nOur background worker watches the database for changes.\nWhenever an event happens,\nthe Worker will find the appropriate worker function for that event\nand call it.\n\nIn `$SISYPHUS/src/worker.coffee`:\n\n```coffeescript\n...\n\ndb = couch_utils.nano_system_user.use('boulders')\n\n# return a promise, rather than using callbacks\ndoAction = require('pantheon-helpers/lib/doAction')\nPromise = require('pantheon-helpers/lib/promise')\n\nhandlers: {\n  # worker functions for boulder documents\n  boulder:\n    'bu': (event, doc, logger) ->\n      # wait two minutes, then fire off a 'bd' event\n      Promise.setTimeout(120000).next(() ->\n        doAction(db, doc._id, {a: 'bd'})\n      ).next(() ->\n        # determine how Zeus felt about it\n        zeus_response = _.sample([\n          'delighted', 'satisfied', 'mirthful', 'vengeful'\n        ])\n        # return that Zeus's response so we can store in in doc.\n        Promise.resolve({data: {is: zeus_response} path: ['zeus']})\n      )\n    'bd': (event, doc, logger) ->\n      # wait 20 second, then fire off a 'br' event\n      Promise.setTimeout(20000).next(() ->\n        doAction(db, doc._id, {a: 'br'})\n      ).next(() ->\n        # determine how Zeus felt about it\n        zeus_reaction = _.sample(['expectant'])\n        # return Zeus's reaction so we can store in in doc.\n        # note that we _must_ return a promise, not a raw value.\n        # the value returned by a handler must be a dictionary\n        # the object pointed to by path into the doc must also be a dict.\n        # the object pointed to by path will be updated with the data dict's contents.\n        Promise.resolve({data: {is: zeus_reaction}, path: ['zeus']})\n      )\n    # we don't need to do anything when a boulder is created or comes to rest\n    'b+': null\n    'br': null\n}\n\n...\n```\n\nA couple things:\n  * Worker handlers MUST return a promise.\n  * Any `data` returned in the promise will be merged into the\n    document at the specified `path`. \n    Thus both `data` and the object at `path` must be hashes.\n  * If your worker handler errors out, then the event will be marked\n    as having errored.\n    While not implemented yet,\n    pantheon-helpers will eventually log the exact error and retry at a later time\n  * **logging:** \n    The fact that your handler has been called,\n    as well as the response and state (resolved/rejected),\n    is logged by pantheon helpers.\n    If you want to log additional information, \n    you can use the logger,\n    which is passed as the third argument to your worker handler.\n    You can create a log entry by making a call such as `logger.info({optional: 'metadata'}, 'log msg')`.\n    See https://github.com/trentm/node-bunyan for full documentation.\n    The relevant metadata linking your log entry to the particular document/revision action with which it is being called has already been included in the logger, s\n    o you do not have to add this metadata.\n\n### 7. Create the API\nTo have a working app, now all we need to do is set up our api.\n\nWe have two endpoints: `/boulders` and `boulders/:boulderId`.\nWe will correspondingly implement our route handlers in\n`$SISYPHUS/src/api/boulders.coffee`\nand `$SISYPHUS/src/api/boulder.coffee`.\n\n$SISYPHUS/src/api/boulders.coffee:\n\n```coffeescript  \ndoAction = require('pantheon-helpers/lib/doAction')\n\nb = {}\n\nb.createBoulder = (db, callback) ->\n  return doAction(db, 'boulder', null, {a: 'b+'}, callback)\n\nb.handleCreateBoulder = (req, resp) ->\n  db = req.couch.use('boulder')\n  b.createBoulder(db).pipe(resp)\n\nmodule.exports = b\n```\n\nAnd that's it. Let's unpack this a bit. \nWe created two functions:\n`createBoulder` and `handleCreateBoulder`.\nThis is a convention used throughout the pantheon. \nThe plain `createBoulder` does the actual work.\nThe `handleCreateBoulder` handles an http request by calling `createBoulder`.\nThis way, you can perform api actions within your application without\nmaking an http request. It also makes testing easier.\n\n`handleCreateBoulder` gets a CouchDB client from req.couch.\nreq.couch is a CouchDB client that has been authenticated as\nwhichever user authenticated against your application. \nThis way, your validation functions in couch can also handle authorization.\n\nYou'll also notice that we did not pass a callback to b.createBoulder.\nb.createBoulder returns a stream of the CouchDB response.\nWe can then pipe that response directly to our response object.\nThis is very memory efficient. \nNode does not have to receive the entire couch response into memory before sending it to the client. \nInstead, it just acts as a proxy, forwarding the CouchDB response to the client as it is received.\n\n$SISYPHUS/src/api/boulder.coffee:\n\n```coffeescript\ndoAction = require('pantheon-helpers/lib/doAction')\n\nb = {}\n\nb.getBoulder = (db, boulderId, callback) ->\n  return db.get(boulderId, callback)\n\nb.rollBoulderUp = (db, boulderId, callback) ->\n  return doAction(db, 'boulder', boulderId, {a: 'bu'}, callback)\n\nb.handleRollBoulderUp = (req, resp) ->\n  db = req.couch.use('boulder')\n  boulderId = req.params.boulderId\n  b.rollBoulderUp(db, boulderId).pipe(resp)\n\nb.rollBoulderDown = (db, boulderId, callback) ->\n  return doAction(db, 'boulder', boulderId, {a: 'bd'}, callback)\n\nb.handleRollBoulderDown = (req, resp) ->\n  db = req.couch.use('boulder')\n  boulderId = req.params.boulderId\n  b.rollBoulderDown(db, boulderId).pipe(resp)\n\nmodule.exports = b\n```\n\n$SISYPHUS/routes.coffee:\n\n```coffeescript\nboulders = require('./api/boulders')\nboulder = require('./api/boulder')\n\nmodule.exports = (app) ->\n  app.post('/sisyphus/boulders/', boulders.handleCreateBoulder)\n\n  app.get('/sisyphus/boulders/:boulderId', boulder.handleGetBoulder)\n  app.put('/sisyphus/boulders/:boulderId/state/down', boulder.handleRollBoulderDown)\n  app.put('/sisyphus/boulders/:boulderId/state/up', boulder.handleRollBoulderUp)\n```\n\nYou now have a fully functioning application with auditing, logging, and a background worker process.\n\nThanks for reading!\n",
  "readmeFilename": "README.md",
  "_id": "pantheon-helpers@0.1.0",
  "dist": {
    "shasum": "cdeee8f383ea6337c895b56cae2fdff1c7e73150"
  },
  "_resolved": "git+https://github.com/cfpb/pantheon-helpers.git#c0a72b45a2283d6fc595d59c3df831f8565bde6f",
  "_from": "pantheon-helpers@git+https://github.com/cfpb/pantheon-helpers.git"
}
